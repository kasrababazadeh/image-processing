# -*- coding: utf-8 -*-
"""Untitled8.ipynb

Automatically generated by Colab.

Original file is located at
    https://colab.research.google.com/drive/193OEwsmgnlRj-9KVO8d-5F14XuIuzoz4
"""

import os
import numpy as np
from numpy.fft import fft2, ifft2
from scipy.signal import convolve2d
import matplotlib.pyplot as plt
import cv2

def motion_blur(img, kernel_size=3):
    """Applies motion blur to an image using a simple averaging kernel."""
    dummy = np.copy(img)
    # Create a normalized motion blur kernel
    h = np.eye(kernel_size) / kernel_size
    # Perform convolution in 2D
    dummy = convolve2d(dummy, h, mode='same', boundary='wrap')  # Use 'same' for consistent output size
    return dummy

def add_gaussian_noise(img, sigma):
    """Adds Gaussian noise to an image."""
    gauss = np.random.normal(0, sigma, img.shape)
    noisy_img = img + gauss
    noisy_img[noisy_img < 0] = 0
    noisy_img[noisy_img > 255] = 255
    return noisy_img

def wiener_filter(img, kernel, k):
    """Applies Wiener filter to an image."""
    kernel /= np.sum(kernel)
    dummy = fft2(img)
    kernel = fft2(kernel, s=img.shape)
    kernel = np.conj(kernel) / (np.abs(kernel) ** 2 + k)
    dummy = dummy * kernel
    dummy = np.abs(ifft2(dummy))
    return dummy

def gaussian_kernel(kernel_size=3, sigma=1.0):
    """Creates a Gaussian kernel."""
    ax = np.linspace(-(kernel_size - 1) / 2., (kernel_size - 1) / 2., kernel_size)
    x, y = np.meshgrid(ax, ax)
    h = np.exp(-(x**2 + y**2) / (2 * sigma**2))
    h /= np.sum(h)  # Normalize the kernel
    return h

def rgb2gray(rgb):
    """Converts an RGB image to grayscale."""
    return np.dot(rgb[..., :3], [0.2989, 0.5870, 0.1140])

def mse(imageA, imageB):
    """Calculates the mean squared error between two images."""
    if imageA.shape != imageB.shape:
        # Resize imageB to match imageA
        imageB = cv2.resize(imageB, (imageA.shape[1], imageA.shape[0]))

    err = np.sum((imageA.astype("float") - imageB.astype("float")) ** 2)
    err /= float(imageA.shape[0] * imageA.shape[1])
    return err

def process_image(file_path, kernel_size=3, noise_sigma=100, wiener_k=0.4):
    """Processes the input image with motion blur, Gaussian noise, and Wiener filter."""
    if not os.path.isfile(file_path):
        raise FileNotFoundError(f"The file {file_path} does not exist.")

    # Read and convert the image to grayscale
    img = plt.imread(file_path)
    if img.ndim == 3:  # Check if the image is RGB
        img = rgb2gray(img)  # Convert to grayscale

    # Ensure img is in float format
    img = img.astype(np.float32)

    # Apply motion blur
    blurred_img = motion_blur(img, kernel_size)

    # Add Gaussian noise
    noisy_img = add_gaussian_noise(blurred_img, sigma=noise_sigma)

    # Create Gaussian kernel for filtering
    kernel = gaussian_kernel(kernel_size)

    # Apply Wiener filter
    filtered_img = wiener_filter(noisy_img, kernel, wiener_k)

    # Display results
    display_images(img, blurred_img, noisy_img, filtered_img)

    # Calculate MSE values
    original_mse = mse(img, noisy_img)
    filtered_mse = mse(img, filtered_img)
    print(f'MSE between original and noisy image: {original_mse:.2f}')
    print(f'MSE between original and filtered image: {filtered_mse:.2f}')

def display_images(original, blurred, noisy, filtered):
    """Displays the original, blurred, noisy, and filtered images."""
    display = [original, blurred, noisy, filtered]
    labels = ['Original Image', 'Motion Blurred Image', 'Motion Blurring + Gaussian Noise', 'Wiener Filter Applied']

    fig = plt.figure(figsize=(12, 10))
    for i in range(len(display)):
        fig.add_subplot(2, 2, i + 1)
        plt.imshow(display[i], cmap='gray')
        plt.title(labels[i])
        plt.axis('off')  # Hide axes
    plt.tight_layout()
    plt.show()

# Example usage
process_image('/content/bitewing.jpg', kernel_size=15, noise_sigma=100)